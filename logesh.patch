diff --git a/lib/api.ex b/lib/api.ex
index 203796e..9063be1 100644
--- a/lib/api.ex
+++ b/lib/api.ex
@@ -2,10 +2,10 @@ defmodule Onvif.API do
   @moduledoc false

   @spec client(Onvif.Device.t(), Keyword.t()) :: Tesla.Client.t()
-  def client(device, opts \\ [service_path: "/onvif/device_service"]) do
+  def client(device, opts \\ [service_path: :device_service_path]) do
     adapter = {Tesla.Adapter.Finch, name: Onvif.Finch}
     service_path = Map.fetch!(device, opts[:service_path])
-    uri = device.address <> opts[:service_path]
+    uri = device.address <> service_path
     parsed_uri = URI.parse(uri)
     no_userinfo_uri = %URI{parsed_uri | userinfo: nil} |> URI.to_string()

diff --git a/lib/device.ex b/lib/device.ex
index 64b6b20..2c04b6c 100644
--- a/lib/device.ex
+++ b/lib/device.ex
@@ -15,10 +15,11 @@ defmodule Onvif.Device do
                 :serial_number,
                 :hardware_id,
                 :ntp,
+                :media_ver10_service_path,
+                :media_ver20_service_path,
                 auth_type: :xml_auth,
                 time_diff_from_system_secs: 0,
                 port: 80,
-                supports_media2?: false,
                 device_service_path: "/onvif/device_service"
               ]

@@ -77,6 +78,7 @@ defmodule Onvif.Device do
          {:ok, updated_device} <- guess_auth(device_with_datetime) do
       updated_device
       |> get_services()
+      |> set_media_service_path()
     end
   end

@@ -202,4 +204,24 @@ defmodule Onvif.Device do
       Map.put(device, :services, services)
     end
   end
+
+  defp set_media_service_path(device) do
+    device
+    |> Map.put(:media_ver10_service_path, get_media_ver10_service_path(device.services))
+    |> Map.put(:media_ver20_service_path, get_media_ver20_service_path(device.services))
+  end
+
+  defp get_media_ver20_service_path(services) do
+    case Enum.find(services, &String.contains?(&1.namespace, "ver20/media")) do
+      nil -> nil
+      %Onvif.Device.Service{} = service -> service.xaddr |> URI.parse() |> Map.get(:path)
+    end
+  end
+
+  defp get_media_ver10_service_path(services) do
+    case Enum.find(services, &String.contains?(&1.namespace, "ver10/media")) do
+      nil -> nil
+      %Onvif.Device.Service{} = service -> service.xaddr |> URI.parse() |> Map.get(:path)
+    end
+  end
 end
diff --git a/lib/media/ver10/media.ex b/lib/media/ver10/media.ex
index 8f04429..dba1121 100644
--- a/lib/media/ver10/media.ex
+++ b/lib/media/ver10/media.ex
@@ -17,10 +17,9 @@ defmodule Onvif.Media.Ver10.Media do
   def request(%Device{} = device, args \\ [], operation) do
     content = generate_content(operation, args)
     soap_action = operation.soap_action()
-    service_path = get_service_path(device)

     device
-    |> Onvif.API.client(service_path: service_path)
+    |> Onvif.API.client(service_path: :media_ver10_service_path)
     |> Tesla.request(
       method: :post,
       headers: [{"Content-Type", "application/soap+xml"}, {"SOAPAction", soap_action}],
@@ -48,11 +47,4 @@ defmodule Onvif.Media.Ver10.Media do
   defp parse_response({:error, response}, operation) do
     {:error, %{status: nil, reason: "Error performing #{operation}", response: response}}
   end
-
-  defp get_service_path(device) do
-    case Enum.find(device.services, &String.contains?(&1.namespace, "ver10/media")) do
-      nil -> raise "Media Ver10 is not supported by the device"
-      %Onvif.Device.Service{} = service -> service.xaddr |> URI.parse() |> Map.get(:path)
-    end
-  end
 end
diff --git a/lib/media/ver10/profile/multicast_configuration.ex b/lib/media/ver10/profile/multicast_configuration.ex
index 6adf2f3..671c63a 100644
--- a/lib/media/ver10/profile/multicast_configuration.ex
+++ b/lib/media/ver10/profile/multicast_configuration.ex
@@ -15,7 +15,7 @@ defmodule Onvif.Media.Ver10.Profile.MulticastConfiguration do

     embeds_one :ip_address, IpAddress, primary_key: false, on_replace: :update do
       field(:type, Ecto.Enum, values: [ipv4: "IPv4", ipv6: "IPv6"])
-      field(:ipv4_address, :string, default: "0.0.0.0")
+      field(:ipv4_address, :string)
       field(:ipv6_address, :string)
     end
   end
diff --git a/lib/media/ver10/set_video_encoder_configuration.ex b/lib/media/ver10/set_video_encoder_configuration.ex
index 8eefcea..a98382b 100644
--- a/lib/media/ver10/set_video_encoder_configuration.ex
+++ b/lib/media/ver10/set_video_encoder_configuration.ex
@@ -15,6 +15,8 @@ defmodule Onvif.Media.Ver10.SetVideoEncoderConfiguration do
     element(:"s:Body", [
       element(:"trt:SetVideoEncoderConfiguration", [
         element(:"trt:Configuration", %{"token" => video_encoder_config.reference_token}, [
+          element(:"tt:Name", video_encoder_config.name),
+          element(:"tt:UseCount", video_encoder_config.use_count),
           element(
             :"tt:Encoding",
             Keyword.fetch!(
@@ -22,7 +24,7 @@ defmodule Onvif.Media.Ver10.SetVideoEncoderConfiguration do
               video_encoder_config.encoding
             )
           ),
-          element(:"tt:Quality", video_encoder_config.quality),
+          element(:"tt:Quality", trunc(video_encoder_config.quality)),
           element(
             :"tt:Resolution",
             [
@@ -35,14 +37,17 @@ defmodule Onvif.Media.Ver10.SetVideoEncoderConfiguration do
             element(:"tt:EncodingInterval", video_encoder_config.rate_control.encoding_interval),
             element(:"tt:BitrateLimit", video_encoder_config.rate_control.bitrate_limit)
           ]),
-          multicast_element(video_encoder_config.multicast_configuration)
+          multicast_element(video_encoder_config.multicast_configuration),
+          element(:"tt:SessionTimeout", video_encoder_config.session_timeout)
         ])
-      ])
+      ]),
+      element(:"trt:ForcePersistence", true)
     ])
   end

   defp multicast_element(%{ip_address: %{type: :ipv4}} = multicast_configuration) do
     element(:"tt:Multicast", [
+      # element(:"tt:Address", 0),
       element(:"tt:Address", [
         element(
           :"tt:Type",
@@ -84,6 +89,7 @@ defmodule Onvif.Media.Ver10.SetVideoEncoderConfiguration do
       ~x"//s:Envelope/s:Body/trt:SetVideoEncoderConfigurationResponse/text()"s
       |> add_namespace("s", "http://www.w3.org/2003/05/soap-envelope")
       |> add_namespace("trt", "http://www.onvif.org/ver10/media/wsdl")
+      |> add_namespace("tt", "http://www.onvif.org/ver10/schema")
     )
   end
 end
diff --git a/lib/media/ver20/media.ex b/lib/media/ver20/media.ex
index 9cedfae..c1edb18 100644
--- a/lib/media/ver20/media.ex
+++ b/lib/media/ver20/media.ex
@@ -17,10 +17,9 @@ defmodule Onvif.Media.Ver20.Media do
   def request(%Device{} = device, args \\ [], operation) do
     content = generate_content(operation, args)
     soap_action = operation.soap_action()
-    service_path = get_service_path(device)

     device
-    |> Onvif.API.client(service_path: service_path)
+    |> Onvif.API.client(service_path: :media_ver20_service_path)
     |> Tesla.request(
       method: :post,
       headers: [{"Content-Type", "application/soap+xml"}, {"SOAPAction", soap_action}],
@@ -48,11 +47,4 @@ defmodule Onvif.Media.Ver20.Media do
   defp parse_response({:error, response}, operation) do
     {:error, %{status: nil, reason: "Error performing #{operation}", response: response}}
   end
-
-  defp get_service_path(device) do
-    case Enum.find(device.services, &String.contains?(&1.namespace, "ver20/media")) do
-      nil -> raise "Media Ver20 is not supported by the device"
-      %Onvif.Device.Service{} = service -> service.xaddr |> URI.parse() |> Map.get(:path)
-    end
-  end
 end
